**Анализ степени распараллеливания линейных участков**

Для современных вычислительных систем характерно наличие как универсальных процессоров, так и множества специализированных аппаратных ускорителей. В этой связи приобретает важность задача программно-аппаратного разбиения выполнения фрагментов кода с целью достижения требуемых характеристик, таких, например, как быстродействие или энергопотребление. В частности, выявление в часто исполняемом фрагменте программы высокой степени параллелизма уровня команд может быть основанием для переноса выполнения кода
на специализированный процессор с архитектурой VLIW.

Выявление степени параллелизма уровня команд может быть осуществлено с помощью статического анализа,
дополненного информацией о наиболее часто выполняемых линейных участках. Эта дополнительная информация может быть получена с помощью средств профилирования программ. С использованием библиотеки llvm2py
разработан рассматриваемый далее инструмент статического анализа степени распараллеливания на уровне линейных участков в представлении LLVM IR.
Представление LLVM IR можно рассматривать, как машинный код абстрактного LLVM-процессора с неограниченным числом регистров и единственным функциональным узлом, выполняющим команду LLVM IR за такт.

Расширением абстрактного LLVM-процессора является его вариант, обладающий бесконечным числом параллельно работающих функциональных узлов. С точки зрения анализа степени распараллеливания уровня команд
интерес представляют следующие показатели:

1. Коэффициент a ускорения выполнения линейного участка на параллельном LLVM-процессоре по сравнению с последовательным вариантом.
2. Число w параллельно работающих функциональных узлов, обеспечивающих достижение максимального
значения коэффициента ускорения.

С использованием этих показателей распараллеливания может быть осуществлен не только выбор среди существующих аппаратных решений, но и обоснование проектирования нового аппаратного ускорителя.

Каждый линейный участок анализируется инструментом анализа степени распараллеливания отдельно, в соответствии с этапами, показанными на @fig:make3, а в качестве результата выдаются значения показателей распараллеливания.

![Схема работы инструмента анализа степени распараллеливания линейных участков](./images/png3.png){#fig:make3 width="6.5in"}

Первым этапом осуществляется преобразование линейного участка на языке LLVM IR в ГЗ [@sovetov2021], в котором
узлы представляют собой команды, а ребра задают зависимости двух видов: по данным и по состоянию памяти.
Предполагается, что после использования опций компилятора для разворачивания циклов и встраивания функций наиболее высокий потенциал распараллеливания уровня команд имеют линейные участки, не содержащие
вызовов функций. Поэтому в ГЗ транслируются только линейные участки без вызовов функций, за исключением
вызовов встроенных функций (intrinsics), не имеющих побочного эффекта.

Следующим этапом реализуется построение ЯПФ [@fet1995]. Каждый ярус ЯПФ представляет собой множество всех
команд, выполнение которых зависит только от результатов вычисления предыдущих ярусов. Таким образом,
ярус – это шаг вычислений параллельного LLVM-процессора, причем каждая команда яруса выполняется на
своем функциональном узле. Общее количество ярусов определяет число шагов для выполнения линейного
участка. Псевдокод алгоритма построения ЯПФ приведен на @fig:make4.

На вход алгоритма построения ЯПФ подается граф зависимостей G, а результатом работы алгоритма является
таблица L, в которой каждому номеру яруса соответствует множество команд, расположенных на соответствующем ярусе

![Псевдокод алгоритма построения ЯПФ](./images/png4.png){#fig:make4 width="6.5in"}

Выполнение алгоритма продолжается, пока в графе G остаются необработанные узлы (строка 4). Основным
шагом алгоритма является определение такого узла n (строка 6), аргументы которого уже обработаны (строка 7).

Если n удовлетворяет этому условию, то узел добавляется к множеству узлов текущего яруса (строка 8). После
очередного просмотра графа G из него исключается множество узлов текущего яруса (строка 9).

Из таблицы L можно получить значение количества ярусов d, то есть минимальное число шагов параллельного LLVM-процессора, необходимых для выполнения некоторого линейного участка, а также значение $w_max –
размер наиболее широкого яруса.

Коэффициент ускорения a определяется следующим образом:

\vspace{0.6cm}
\begin{center}

$a = \frac{|G|}{d}$.

\end{center}
\vspace{0.6cm}

Рассматриваемый алгоритм относится к жадным алгоритмам, что приводит к построению ярусов максимальной ширины (максимальная ЯПФ). В этой связи возникает задача минимизации ширины ЯПФ, то есть минимизации числа используемых в вычислениях параллельно работающих функциональных узлов.

На этапе построения минимальной ЯПФ решается задача минимизации ширины ЯПФ, формулировка которой
сведена к задаче программирования в ограничениях, аналогично тому, как это сделано в [@sovietov2023]. При этом используются полученные в результате выполнения алгоритма построения ЯПФ значения d и w_max.

Номер назначенного яруса для каждого узла ГЗ содержится в переменной p:

\vspace{0.6cm}
\begin{center}

$p_n \in \{0, \ldots, d-1\}, \forall n \in G$.

\end{center}
\vspace{0.6cm}

Заданы ограничения на расположение в ярусах с учетом зависимостей между узлами – вычисленные аргументы команд должны предшествовать самим командам:

\vspace{0.6cm}
\begin{center}

$\forall n \in G, \forall a \in args(G[n]):p_a < p_n$.

\end{center}
\vspace{0.6cm}

Булева матрица $x_i,_n \in {0,1}$ определяет для каждого яруса с номером i наличие в нем узла n:

\begin{center}

\[ \forall i \in \{0, \ldots, d-1\}, \forall n \in G:
  \begin{cases}
    x_{i,n}=1 \Rightarrow p_n=i\\
    x_{i,n}=0 \Rightarrow p_n \neq i
  \end{cases}
\]  

\end{center}

Ширина каждого i-го яруса ограничивается значением максимальной ширины $w \in \{0, \ldots, w_{max}\}$:

\vspace{0.6cm}
\begin{center}

$\sum x_i \le w$.

\end{center}
\vspace{0.6cm}

Задача минимизации ширины ЯПФ с учетом заданных ограничений формулируется следующим образом:

\vspace{0.6cm}
\begin{center}

$min w$.

\end{center}
\vspace{0.6cm}

В рассматриваемом инструменте анализа степени распараллеливания решение этой задачи реализовано с помощью решателя CP-SAT из состава программного пакета OR-Tools [@ortools2023].